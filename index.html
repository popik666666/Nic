<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Audio stream + playlist p≈ôes WebRTC s PeerJS a synchronizac√≠</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; background: #121212; color: #eee; }
  h1 { margin-bottom: 10px; }
  label, select, button, input { font-size: 1.1em; margin-top: 10px; display: block; }
  #senderUI, #receiverUI { margin-top: 20px; }
  audio { margin-top: 10px; width: 100%; outline: none; border-radius: 6px; background: #222; }
  button { padding: 10px 20px; background: #0b84ff; border: none; border-radius: 6px; color: white; cursor: pointer; margin-right: 5px; }
  button:disabled { background: #555; cursor: not-allowed; }
  #status { margin-top: 15px; font-weight: bold; min-height: 1.5em; color: #0b84ff; }
  #playlist { margin-top: 10px; max-height: 200px; overflow-y: auto; border: 1px solid #555; padding: 5px; list-style-type: none; }
  #playlist li { cursor: pointer; padding: 5px; margin-bottom: 2px; border-radius: 4px; }
  #playlist li:hover { background: #333; }
  #playlist li.active { background: #0b84ff; font-weight: bold; }
  #controls { margin-top: 10px; }
  #peerIdInput, #senderPeerIdInput, #turnUrlInput, #turnUsernameInput, #turnCredentialInput, #streamUrlInput { 
    width: 300px; padding: 5px; margin-top: 10px; background: #222; border: 1px solid #444; color: #eee; border-radius: 4px; 
  }
  /* STYL PRO ODVODNƒöN√ç AUTOPLAY */
  #unmuteBtn { background: #ff0b3c !important; display: none; margin: 15px auto; padding: 15px 30px; font-size: 1.2em; font-weight: bold; }
  /* Styl pro kontejner QR k√≥du na vys√≠laƒçi (b√≠l√Ω, aby byl QR k√≥d vidƒõt) */
  #qrcodeContainer { background: white; padding: 10px; border-radius: 8px; display: inline-block; margin-top: 15px; }
  #peerIdDisplay { font-weight: bold; margin-bottom: 5px; color: #333; }
  /* Styl pro skener QR k√≥du na p≈ôij√≠maƒçi */
  #readerContainer { margin-top: 15px; display: flex; justify-content: center; }
  #pasteIdBtn, #copyIdBtn { margin-left: 10px; display: inline-block; }
  
  /* Upraven√≠ tlaƒç√≠tek v ovl√°d√°n√≠ pro lep≈°√≠ vzhled */
  #controls button, #controlsReceiver button {
      padding: 8px 15px;
      margin-right: 8px;
      display: inline-block;
  }
</style>
</head>
<body>
  <h1>Audio stream + playlist p≈ôes WebRTC s PeerJS a synchronizac√≠</h1>

  <label for="role">Vyber roli:</label>
  <select id="role">
    <option value="sender">Vys√≠laƒç (stream audio)</option>
    <option value="receiver">P≈ôij√≠maƒç (poslech)</option>
  </select>

  <div id="senderUI" style="display:none;">
    <h2>Vys√≠laƒç</h2>
    
    <input type="text" id="streamUrlInput" placeholder="Zadejte URL streamu (nap≈ô. http://icecast.com/stream.mp3)" 
           style="width: 300px; padding: 5px; margin-top: 10px; background: #222; border: 1px solid #444; color: #eee; border-radius: 4px; display: block;" />
    <button id="addUrlToPlaylistBtn">P≈ôidat URL do playlistu (Zkusit CORS Proxy)</button> 
    <hr style="border-color:#333; margin: 15px 0;">
    
    <input type="file" id="audioFileInput" accept="audio/*" multiple />
    <button id="addToPlaylistBtn" disabled>P≈ôidat soubor(y) do playlistu</button>
    
    <h3>Playlist</h3>
    <ul id="playlist"></ul>
    
    <button id="startPlaylistBtn" disabled style="background:#28a745;">Start p≈ôehr√°v√°n√≠ playlistu</button>
    <audio id="audioSource" controls></audio>
    <div id="controls" style="margin-top:5px;">
      <button id="prevBtn" disabled>‚èÆÔ∏è P≈ôedchoz√≠</button>
      <button id="playBtn" disabled>‚ñ∂Ô∏è Play</button>
      <button id="pauseBtn" disabled>‚è∏Ô∏è Pauza</button>
      <button id="nextBtn" disabled>‚è≠Ô∏è Dal≈°√≠</button>
    </div>
    
    <hr style="border-color:#333; margin: 15px 0;">
    <h3>Konfigurace TURN Serveru (Voliteln√©)</h3>
    <p style="font-size: 0.9em; margin-top: 0;">Zadejte vlastn√≠ TURN server pro robustn√≠ NAT traversal.</p>
    <input type="text" id="turnUrlInput" placeholder="TURN URL (nap≈ô. turn:vas.server.com:3478)" />
    <input type="text" id="turnUsernameInput" placeholder="TURN U≈æivatelsk√© jm√©no" />
    <input type="password" id="turnCredentialInput" placeholder="TURN Heslo/Kredenci√°l" />
    
    <p style="margin-top: 15px;">Peer ID: <input id="senderPeerIdInput" type="text" placeholder="Zadej vlastn√≠ Peer ID" /></p>
    <button id="initPeerBtn" style="background:#ff6600;">Inicializovat Peer (vys√≠laƒç)</button>
    
    <div id="qrcodeContainer" style="display:none;">
        <p id="peerIdDisplay"></p>
        <div id="qrcode"></div>
        <button id="copyIdBtn" style="margin-top: 10px; background: #28a745;">Kop√≠rovat ID</button>
    </div>
    </div>

  <div id="receiverUI" style="display:none;">
    <h2>P≈ôij√≠maƒç</h2>
    <input type="text" id="peerIdInput" placeholder="Zadej Peer ID vys√≠laƒçe" />
    <button id="connectBtn">P≈ôipojit</button>
    <button id="pasteIdBtn" style="margin-top: 15px; background: #007bff;">Vlo≈æit ID ze schr√°nky</button>
    
    <button id="scanQrBtn" style="margin-top: 15px;">Skenovat QR K√≥d</button>
    <div id="readerContainer">
        <div id="reader"></div>
    </div>
    <div id="autoplayBlocker" style="text-align: center;">
        <button id="unmuteBtn">KLIKNƒöTE PRO POVOLEN√ç ZVUKU</button>
    </div>
    
    <audio id="audioReceiver" controls autoplay></audio>
    <div id="controlsReceiver" style="margin-top:5px;">
      <button id="prevBtnR" disabled>‚èÆÔ∏è P≈ôedchoz√≠</button>
      <button id="playBtnR" disabled>‚ñ∂Ô∏è Play</button>
      <button id="pauseBtnR" disabled>‚è∏Ô∏è Pauza</button>
      <button id="nextBtnR" disabled>‚è≠Ô∏è Dal≈°√≠</button>
    </div>
  </div>

  <div id="status"></div>

  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://unpkg.com/html5-qrcode"></script>
  <script>
    // --- KONSTANTY PRO LOCAL STORAGE ---
    const SENDER_ID_KEY = 'webrtc_sender_peer_id';
    const PLAYLIST_KEY = 'webrtc_playlist';
    // ----------------------------------

    const roleSelect = document.getElementById('role');
    const senderUI = document.getElementById('senderUI');
    const receiverUI = document.getElementById('receiverUI');
    const audioFileInput = document.getElementById('audioFileInput');
    const addToPlaylistBtn = document.getElementById('addToPlaylistBtn');
    const playlistEl = document.getElementById('playlist');
    const startPlaylistBtn = document.getElementById('startPlaylistBtn');
    const audioSource = document.getElementById('audioSource');
    const audioReceiver = document.getElementById('audioReceiver');
    const statusDiv = document.getElementById('status');
    const senderPeerIdInput = document.getElementById('senderPeerIdInput');
    const initPeerBtn = document.getElementById('initPeerBtn');
    const peerIdInput = document.getElementById('peerIdInput');
    const connectBtn = document.getElementById('connectBtn');
    
    // --- P≈ÆVODN√ç NOV√â PROMƒöNN√â PRO URL STREAM + AUTOPLAY ---
    const streamUrlInput = document.getElementById('streamUrlInput');
    const addUrlToPlaylistBtn = document.getElementById('addUrlToPlaylistBtn'); 
    const unmuteBtn = document.getElementById('unmuteBtn');
    // --- NOV√â PROMƒöNN√â PRO QR K√ìD A COPY/PASTE ---
    const qrcodeContainer = document.getElementById('qrcodeContainer');
    const peerIdDisplay = document.getElementById('peerIdDisplay');
    const scanQrBtn = document.getElementById('scanQrBtn');
    const readerContainer = document.getElementById('readerContainer');
    const copyIdBtn = document.getElementById('copyIdBtn');
    const pasteIdBtn = document.getElementById('pasteIdBtn');
    let html5QrCode = null;
    
    // --- NOV√â PROMƒöNN√â PRO TURN KREDENCI√ÅLY ---
    const turnUrlInput = document.getElementById('turnUrlInput');
    const turnUsernameInput = document.getElementById('turnUsernameInput');
    const turnCredentialInput = document.getElementById('turnCredentialInput');
    // ------------------------------------------

    // Ve≈ôejn√© CORS proxy
    const PROXIES = [
        'https://corsproxy.io/?',
        'https://api.allorigins.win/raw?url=',
        'https://thingproxy.freeboard.io/fetch/',
    ];

    // Ovl√°dac√≠ tlaƒç√≠tka
    const prevBtn = document.getElementById('prevBtn');
    const playBtn = document.getElementById('playBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const nextBtn = document.getElementById('nextBtn');
    const prevBtnR = document.getElementById('prevBtnR');
    const playBtnR = document.getElementById('playBtnR');
    const pauseBtnR = document.getElementById('pauseBtnR');
    const nextBtnR = document.getElementById('nextBtnR');

    let peerJs = null;
    let conn = null; // DataConnection
    let mediaConn = null; // MediaConnection
    let audioStreamSource = null; // MediaStream z vys√≠laƒçe
    let audioContext = null; // Web Audio Context
    
    // üî• NOV√â: Glob√°ln√≠ promƒõnn√© pro spr√°vu Web Audio grafu
    let sourceNode = null; 
    let destNode = null;   

    let playlist = [];
    let currentTrackIndex = -1;
    let peerIndex = 0; 

    // --- FUNKCE PRO DYNAMICKOU KONFIGURACI ICE SERVER≈Æ (VYLEP≈†ENO) ---
    function getIceConfig() {
      const customUrl = turnUrlInput.value.trim();
      const customUsername = turnUsernameInput.value.trim();
      const customCredential = turnCredentialInput.value.trim();
      
      const iceServers = [
        // STUN servery
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun.services.mozilla.com:3478' },
        { urls: 'stun:stun.stunprotocol.org' },
      ];
      
      // Pokud jsou vyplnƒõny custom TURN √∫daje, pou≈æijeme je jako prvn√≠ volbu
      if (customUrl && customUsername && customCredential) {
        logStatus('Pou≈æ√≠v√°m vlastn√≠ TURN server pro konfiguraci ICE.');
        iceServers.unshift({
          urls: customUrl,
          username: customUsername,
          credential: customCredential
        });
      }

      // Ve≈ôejn√© TURN servery (jako fallback)
      iceServers.push(
        { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' },
        { urls: 'turn:openrelay.metered.ca:443', username: 'openrelayproject', credential: 'openrelayproject' },
        { urls: 'turn:openrelay.metered.ca:3478', username: 'openrelayproject', credential: 'openrelayproject' }
      );
      
      return { 
        iceTransportPolicy: 'relay', // Vynut√≠ pou≈æit√≠ TURN, co≈æ zvy≈°uje ≈°anci na spojen√≠
        iceServers: iceServers 
      };
    }
    // ---------------------------------------------------


    // Konfigurace PeerJS server≈Ø
    const peerConfigs = [
      { host: '0.peerjs.com', port: 443, secure: true },
      { host: '1.peerjs.com', port: 443, secure: true },
      { host: '2.peerjs.com', port: 443, secure: true }
    ];

    function logStatus(msg) {
      statusDiv.innerHTML = msg; // Pou≈æ√≠v√°me innerHTML pro form√°tov√°n√≠, pokud by bylo pot≈ôeba
      console.log(msg.replace(/<[^>]*>?/gm, '')); // ƒåist√Ω log bez HTML
    }
    
    // --- FUNKCE PRO PERSISTENTN√ç LOCAL STORAGE ---
    function savePlaylistToLocal() {
        try {
            // Ukl√°d√°me pouze data, kter√° nejsou blob URL (lok√°ln√≠ soubory), proto≈æe by po reloadu byly neplatn√©
            const serializablePlaylist = playlist.filter(track => !track.url.startsWith('blob:'));
            
            localStorage.setItem(PLAYLIST_KEY, JSON.stringify(serializablePlaylist));
            logStatus('Playlist ulo≈æen do lok√°ln√≠ho √∫lo≈æi≈°tƒõ.');
        } catch (e) {
            console.error('Chyba p≈ôi ukl√°d√°n√≠ playlistu:', e);
        }
    }

    function loadPlaylistFromLocal() {
        try {
            const storedPlaylist = localStorage.getItem(PLAYLIST_KEY);
            if (storedPlaylist) {
                playlist = JSON.parse(storedPlaylist);
                updatePlaylistUI();
            }
        } catch (e) {
            console.error('Chyba p≈ôi naƒç√≠t√°n√≠ playlistu:', e);
        }

        const storedSenderId = localStorage.getItem(SENDER_ID_KEY);
        if (storedSenderId) {
            senderPeerIdInput.value = storedSenderId;
        }
    }
    // ---------------------------------------------


    function showUI(role) {
      if (role === 'sender') {
        senderUI.style.display = 'block';
        receiverUI.style.display = 'none';
        unmuteBtn.style.display = 'none'; 
        qrcodeContainer.style.display = 'none';
        logStatus('Re≈æim Vys√≠laƒç. Inicializujte Peer ID.');
      } else {
        senderUI.style.display = 'none';
        receiverUI.style.display = 'block';
        logStatus('Re≈æim P≈ôij√≠maƒç. P≈ôipojte se k Vys√≠laƒçi.');
      }
    }
    
    function updatePlaylistUI() {
      playlistEl.innerHTML = '';
      playlist.forEach((track, i) => {
        const li = document.createElement('li');
        // Zobrazujeme prvn√≠ch 50 znak≈Ø URL/n√°zvu
        const displayUrl = track.url.startsWith('blob:') ? '[Lok√°ln√≠ Soubor]' : track.url.substring(0, 50) + (track.url.length > 50 ? '...' : '');
        li.textContent = `${i + 1}. ${track.name} (${displayUrl})`;
        if (i === currentTrackIndex) li.classList.add('active');
        li.onclick = () => {
          if (roleSelect.value === 'sender') {
            stopMediaStream(false); 
            playTrack(i);
            sendTrackIndex(i, 0);
            startMediaStream(); 
            updateSenderControls(true); // Aktualizace tlaƒç√≠tek
          }
        };
        playlistEl.appendChild(li);
      });
      
      const enabled = playlist.length > 0 && !!peerJs && peerJs.open;
      startPlaylistBtn.disabled = !enabled;
      updateSenderControls(!audioSource.paused); 
    }

    function updateSenderControls(isPlaying) {
      const enabled = playlist.length > 0 && !!peerJs && peerJs.open;
      const hasNext = currentTrackIndex + 1 < playlist.length;
      const hasPrev = currentTrackIndex > 0;

      prevBtn.disabled = !enabled || !hasPrev;
      playBtn.disabled = !enabled || isPlaying;
      pauseBtn.disabled = !enabled || !isPlaying;
      nextBtn.disabled = !enabled || !hasNext;
      startPlaylistBtn.disabled = !enabled || isPlaying;
    }

    function playTrack(index, currentTime = 0) {
      if (index < 0 || index >= playlist.length) return;
      currentTrackIndex = index;
      const track = playlist[index];
      
      audioSource.crossOrigin = track.url.startsWith('blob:') ? null : "anonymous"; 
      
      audioSource.src = track.url;
      audioSource.currentTime = currentTime;
      
      audioSource.pause();
      audioSource.load();
      
      updatePlaylistUI();
      logStatus(`‚ñ∂Ô∏è Nastavena skladba #${index + 1}: ${track.name}`);
    }

    function setRemoteTrackIndex(index, currentTime = 0) {
      if (index < 0 || index >= playlist.length) return;
      currentTrackIndex = index;
      
      // I kdy≈æ streamujeme, pro UI/Synchronizaci je dobr√© zn√°t n√°zev
      updatePlaylistUI();
      
      logStatus(`P≈ôij√≠maƒç synchronizuje na skladbu #${index + 1}`);

      // Nastaven√≠ ƒçasu se provede a≈æ po startu streamu (jakmile p≈ôijde)
      
      if (audioReceiver.srcObject) {
         // Pokud u≈æ stream bƒõ≈æ√≠, zkus√≠me p≈ôeskoƒçit, ale prim√°rn√≠ je synchronizace ƒçasem
         audioReceiver.currentTime = currentTime; 
      }
      
      if (audioReceiver.paused) {
          audioReceiver.play().catch(() => {});
      }
      updateReceiverControls(!audioReceiver.paused); 
    }

    // üî• NOV√â: Funkce pro modifikaci SDP (vy≈°≈°√≠ bitrate pro Opus)
    function modifySdpForOpus96(sdp) {
      // P≈Øvodn√≠: a=fmtp:111 minptime=10;useinbandfec=1
      // Nov√Ω: a=fmtp:111 minptime=10;useinbandfec=1;maxaveragebitrate=96000;
      return sdp.replace(/a=fmtp:111 minptime=10;useinbandfec=1/g,
        'a=fmtp:111 minptime=10;useinbandfec=1;maxaveragebitrate=96000;stereo=1');
    }

    // üî• VYLEP≈†EN√Å: startMediaStream
    function startMediaStream() {
      if (!conn || !conn.open) {
        logStatus('Nelze streamovat, p≈ô√≠jemce nen√≠ p≈ôipojen (DataChannel). ‚úÖ ƒåek√°m na p≈ôipojen√≠...');
        updateSenderControls(false);
        return;
      }
      if (!audioSource.src) {
        logStatus('Nelze streamovat, nen√≠ vybr√°na ≈æ√°dn√° skladba.');
        updateSenderControls(false);
        return;
      }

      // 1. Lok√°ln√≠ p≈ôehr√°v√°n√≠
      audioSource.play().catch(err => {
        logStatus('üõë Lok√°ln√≠ p≈ôehr√°v√°n√≠ audio zablokov√°no. ' + err.message);
        updateSenderControls(false);
        return;
      });

      // Zpo≈ædƒõn√≠ pro zaji≈°tƒõn√≠, ≈æe audioSource zaƒçne naƒç√≠tat
      setTimeout(() => {
        try {
          if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          if (audioContext.state === 'suspended') audioContext.resume();

          // 2. Spr√°va Web Audio uzl≈Ø
          // Zaji≈°tƒõn√≠, ≈æe p≈ôedchoz√≠ graf je odpojen
          if (sourceNode) sourceNode.disconnect();
          if (destNode) destNode.disconnect();

          sourceNode = audioContext.createMediaElementSource(audioSource);
          destNode = audioContext.createMediaStreamDestination();

          // P≈ôipojen√≠ zdroje k destinaci MediaStreamu a k reproduktor≈Øm
          sourceNode.connect(destNode);
          sourceNode.connect(audioContext.destination); 

          audioStreamSource = destNode.stream;

          // 3. Spu≈°tƒõn√≠ PeerJS hovoru (MediaCall)
          // Zav≈ôeme p≈ôedchoz√≠ MediaConn, pokud existuje (forceRestart)
          if (mediaConn) {
             mediaConn.close();
             mediaConn = null;
          }
          mediaConn = peerJs.call(conn.peer, audioStreamSource);

          // 4. SDP √∫prava pro vy≈°≈°√≠ bitrate
          mediaConn.on('negotiationneeded', () => {
            const pc = mediaConn.peerConnection;
            if (pc) {
              const originalCreateOffer = pc.createOffer.bind(pc);
              pc.createOffer = function() {
                return originalCreateOffer().then(offer => {
                  offer.sdp = modifySdpForOpus96(offer.sdp);
                  return offer;
                });
              };
            }
          });

          mediaConn.on('close', stopMediaStream);
          mediaConn.on('error', err => {
            logStatus('Chyba Media Streamu: ' + err);
            stopMediaStream();
          });

          // 5. Odesl√°n√≠ ≈ô√≠d√≠c√≠ zpr√°vy
          sendControlMessage({ type: 'play', currentTime: audioSource.currentTime });
          logStatus('‚úÖ Media stream zah√°jen k p≈ô√≠jemci.');
          updateSenderControls(true);
        } catch (e) {
          logStatus('Chyba p≈ôi startu Web Audio API/Media: ' + e.message);
          audioSource.pause();
          stopMediaStream(false);
        }
      }, 100);
    }

    // üî• VYLEP≈†EN√Å: stopMediaStream
    function stopMediaStream(sendControl = true) {
      audioSource.pause();
      
      // Odpojen√≠ Web Audio uzl≈Ø
      if (sourceNode) sourceNode.disconnect();
      if (destNode) destNode.disconnect();
      sourceNode = null;
      destNode = null;

      if (mediaConn) {
         // Ukonƒçen√≠ vys√≠lac√≠ho tracku
        if (audioStreamSource) {
            audioStreamSource.getTracks().forEach(track => track.stop());
            audioStreamSource = null;
        }

        mediaConn.close();
        mediaConn = null;
      }

      if (sendControl && conn && conn.open) {
        sendControlMessage({ type: 'pause', currentTime: audioSource.currentTime });
      }
      logStatus('Media stream a lok√°ln√≠ p≈ôehr√°v√°n√≠ zastaveno.');
      updateSenderControls(false);
    }

    audioSource.onended = () => {
      stopMediaStream(false);
      if (currentTrackIndex + 1 < playlist.length) {
        playTrack(currentTrackIndex + 1, 0);
        startMediaStream();
        sendTrackIndex(currentTrackIndex, 0);
      } else {
        logStatus('Playlist dohr√°n');
      }
    };

    audioFileInput.addEventListener('change', () => {
      addToPlaylistBtn.disabled = audioFileInput.files.length === 0;
    });

    addToPlaylistBtn.addEventListener('click', () => {
      const files = audioFileInput.files;
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        const url = URL.createObjectURL(file);
        playlist.push({ name: file.name, url });
      }
      streamUrlInput.value = ''; 
      updatePlaylistUI();
      savePlaylistToLocal();
      addToPlaylistBtn.disabled = true;
      audioFileInput.value = '';
    });

    startPlaylistBtn.addEventListener('click', () => {
      if (playlist.length > 0) {
        // Zaji≈°≈•uje, ≈æe p≈ôi prvn√≠m startu se zaƒçne od nuly
        if (currentTrackIndex === -1 || audioSource.paused) { 
            playTrack(0, 0);
            sendTrackIndex(0, 0);
        }
        startMediaStream();
      }
    });

    function sendTrackIndex(index, currentTime = 0) {
      if (conn && conn.open) {
        conn.send({ type: 'playTrack', index, currentTime });
      }
    }

    function sendControlMessage(msg) {
      if (conn && conn.open) {
        conn.send(msg);
      }
    }

    function sendTimeSync(connection) {
        if (!connection || !connection.open) return;
        
        const syncInterval = setInterval(() => {
            if (!connection.open) {
                clearInterval(syncInterval);
                return;
            }
            if (!audioSource.paused) {
                connection.send({ 
                    type: 'timeSync', 
                    senderTime: audioSource.currentTime 
                });
            }
        }, 1000); 
        
        connection.on('close', () => clearInterval(syncInterval));
    }

    function handleTimeSync(data) {
        if (audioReceiver.srcObject && !audioReceiver.paused) {
            const senderTime = data.senderTime;
            const receiverTime = audioReceiver.currentTime;
            const drift = receiverTime - senderTime; 
            
            const driftFormatted = drift.toFixed(2);
            
            // Oprava driftu nad 0.5s
            if (Math.abs(drift) > 0.5) { 
                logStatus(`‚ö†Ô∏è Synchronizace: Odchylka ${driftFormatted}s. Opravuji ƒças.`);
                audioReceiver.currentTime = senderTime; 
            } else {
                logStatus(`‚úÖ Synchronizace: Odchylka ${driftFormatted}s (v toleranci).`);
            }
        }
    }

    function handleDataMessage(data) {
      if (!data.type) return;

      switch(data.type) {
        case 'playTrack':
          if (typeof data.index === 'number') {
            setRemoteTrackIndex(data.index, data.currentTime || 0);
          }
          break;
        case 'play':
          if (roleSelect.value === 'receiver' && audioReceiver.srcObject) {
            audioReceiver.play().catch(e => {
              unmuteBtn.style.display = 'block'; 
              logStatus('P≈ôehr√°v√°n√≠ zablokov√°no. Kliknƒõte pro povolen√≠ zvuku!');
              updateReceiverControls(false);
            });
            updateReceiverControls(true);
          } else if (roleSelect.value === 'sender') {
             // Zde se jen spust√≠ MediaStream, pokud u≈æ nen√≠ (pro Play na lok√°ln√≠ stranƒõ)
             startMediaStream();
          }
          break;
        case 'pause':
          if (roleSelect.value === 'receiver') {
            audioReceiver.pause();
            updateReceiverControls(false);
          } else if (roleSelect.value === 'sender') {
            stopMediaStream();
          }
          break;
        case 'prev':
          if (roleSelect.value === 'sender') {
            if (currentTrackIndex > 0) {
              stopMediaStream();
              playTrack(currentTrackIndex - 1, 0);
              startMediaStream();
              sendTrackIndex(currentTrackIndex, 0); 
            }
          }
          break;
        case 'next':
          if (roleSelect.value === 'sender') {
            if (currentTrackIndex + 1 < playlist.length) {
              stopMediaStream();
              playTrack(currentTrackIndex + 1, 0);
              startMediaStream();
              sendTrackIndex(currentTrackIndex, 0); 
            }
          }
          break;
        case 'timeSync': 
          if (roleSelect.value === 'receiver') {
            handleTimeSync(data);
          }
          break;
      }
    }

    // --- Ovl√°d√°n√≠ Vys√≠laƒçe (Lok√°ln√≠) ---
    prevBtn.onclick = () => {
      if (currentTrackIndex > 0) {
        stopMediaStream();
        playTrack(currentTrackIndex - 1, 0);
        startMediaStream();
        sendTrackIndex(currentTrackIndex, 0);
      }
    };
    playBtn.onclick = () => {
      if (currentTrackIndex === -1 && playlist.length > 0) {
        playTrack(0, 0);
        sendTrackIndex(0, 0);
      }
      startMediaStream(); // Spust√≠ lok√°ln√≠ p≈ôehr√°v√°n√≠ a stream
    };
    pauseBtn.onclick = () => {
      stopMediaStream();
    };
    nextBtn.onclick = () => {
      if (currentTrackIndex + 1 < playlist.length) {
        stopMediaStream();
        playTrack(currentTrackIndex + 1, 0);
        startMediaStream();
        sendTrackIndex(currentTrackIndex, 0);
      }
    };

    // --- Ovl√°d√°n√≠ P≈ôij√≠maƒçe (Remote) ---
    prevBtnR.onclick = () => {
      const hasPrev = currentTrackIndex > 0;
      if (conn && hasPrev) sendControlMessage({ type: 'prev' });
    };
    
    playBtnR.onclick = () => {
      if (conn) { sendControlMessage({ type: 'play' }); } 
      // Zde zkus√≠me jen lok√°lnƒõ odblokovat zvuk, skuteƒçn√Ω start p≈ôijde p≈ôes DataChannel
      if (audioReceiver.srcObject) {
          audioReceiver.play().catch(e => {
              unmuteBtn.style.display = 'block'; 
              logStatus('P≈ôehr√°v√°n√≠ zablokov√°no. Mobiln√≠ interakce nutn√°!');
              updateReceiverControls(false);
          });
      }
    };
    
    pauseBtnR.onclick = () => {
      if (conn) sendControlMessage({ type: 'pause' });
    };
    nextBtnR.onclick = () => {
      const hasNext = currentTrackIndex + 1 < playlist.length;
      if (conn && hasNext) sendControlMessage({ type: 'next' });
    };

    function updateReceiverControls(isPlaying) {
      const connected = !!conn;
      const hasNext = currentTrackIndex + 1 < playlist.length;
      const hasPrev = currentTrackIndex > 0;
      
      prevBtnR.disabled = !connected || !hasPrev;
      playBtnR.disabled = !connected || isPlaying;
      pauseBtnR.disabled = !connected || !isPlaying;
      nextBtnR.disabled = !connected || !hasNext;
    }
    
    unmuteBtn.onclick = () => {
        if (audioReceiver.srcObject) {
            audioReceiver.play().then(() => {
                logStatus('Zvuk odblokov√°n u≈æivatelsk√Ωm gestem.');
                unmuteBtn.style.display = 'none'; 
                // Po odblokov√°n√≠ po≈°leme Play zpƒõt, aby se synchronizoval Vys√≠laƒç
                if (conn) sendControlMessage({ type: 'play' }); 
            }).catch(e => {
                 logStatus('Odblokov√°n√≠ selhalo: ' + e.message);
            });
        }
    };

    // --- startSender (VYLEP≈†ENO) ---
    function startSender(peerId) {
      if (peerJs) { peerJs.destroy(); peerJs = null; }
      
      qrcodeContainer.style.display = 'none';
      const qrcodeEl = document.getElementById('qrcode');
      qrcodeEl.innerHTML = '';

      function tryNext() {
        if (peerIndex >= peerConfigs.length) {
          logStatus('üõë Nelze se p≈ôipojit k ≈æ√°dn√©mu PeerJS serveru. Zkuste to znovu.');
          peerIndex = 0;
          initPeerBtn.disabled = false;
          return;
        }

        const configBase = peerConfigs[peerIndex];
        const currentIceConfig = getIceConfig(); 
        
        const peerConfig = { ...configBase, config: currentIceConfig };
        
        logStatus(`Zkou≈°√≠m PeerJS server (Vys√≠laƒç): ${configBase.host}`);

        peerJs = new Peer(peerId, peerConfig);
        let opened = false;

        const errorTimeout = setTimeout(() => {
          if (!opened) {
            logStatus(`Timeout: Server ${configBase.host} neodpovƒõdƒõl. Zkou≈°√≠m dal≈°√≠...`);
            peerJs.destroy(); peerJs = null;
            peerIndex++;
            tryNext();
          }
        }, 8000); 

        peerJs.on('open', id => {
          opened = true;
          clearTimeout(errorTimeout);
          logStatus(`‚úÖ Vys√≠laƒç Peer ID: ${id} p≈ôipojeno na server ${configBase.host}. ƒåek√°m na p≈ô√≠jemce...`);
          
          new QRCode(qrcodeEl, { text: id, width: 180, height: 180, colorDark : "#000000", colorLight : "#ffffff", correctLevel : QRCode.CorrectLevel.H });
          peerIdDisplay.textContent = `Naskenujte k√≥d: ${id}`;
          qrcodeContainer.style.display = 'block';
          
          copyIdBtn.onclick = () => {
              navigator.clipboard.writeText(id).then(() => { logStatus('‚úÖ Peer ID zkop√≠rov√°no do schr√°nky!'); }).catch(err => { logStatus('üõë Nepoda≈ôilo se zkop√≠rovat ID: ' + err); });
          };
          
          peerIndex = 0;
          initPeerBtn.disabled = true;
          addToPlaylistBtn.disabled = false;
          updatePlaylistUI();
        });

        peerJs.on('error', err => {
          clearTimeout(errorTimeout);
          logStatus(`‚ùå Chyba na serveru ${configBase.host}: ${err.message}. Zkou≈°√≠m dal≈°√≠...`);
          peerJs.destroy();peerJs = null;
          peerIndex++;
          tryNext();
        });

        peerJs.on('connection', connection => {
          if (conn) { conn.close(); } // Uzav≈ôe p≈ôedchoz√≠, pokud existuje
          conn = connection;
          conn.on('open', () => { 
            logStatus('P≈ôij√≠maƒç p≈ôipojen (DataChannel). Zahajuji synchronizaci...');
            sendTimeSync(conn);
          });

          conn.on('data', handleDataMessage);
          conn.on('close', () => {
            logStatus('P≈ôij√≠maƒç odpojen. ‚úÖ ƒåek√°m na dal≈°√≠ho p≈ô√≠jemce...');
            conn = null;
            // Nech√°me stream bƒõ≈æet, ale zastav√≠me MediaConn, aby se uvolnil port
            if (mediaConn) mediaConn.close();
            mediaConn = null;
            qrcodeContainer.style.display = 'block'; 
          });
          conn.on('error', err => { logStatus('Chyba spojen√≠: ' + err); console.error(err); });
        });

        peerJs.on('call', call => {
          logStatus('Ignorov√°n p≈ô√≠choz√≠ hovor.');
          call.answer();
          call.close();
        });
      }

      peerIndex = 0;
      tryNext();
    }
    // --- KONEC startSender ---

    // --- startReceiver (VYLEP≈†ENO) ---
    function startReceiver() {
      if (peerJs) { peerJs.destroy(); peerJs = null; }
      
      if (html5QrCode && html5QrCode.isScanning) {
          html5QrCode.stop().catch(err => console.log("Chyba p≈ôi zastavov√°n√≠ skeneru", err));
      }
      readerContainer.innerHTML = '<div id="reader"></div>';
      
      const currentIceConfig = getIceConfig(); 

      function tryNextReceiver() {
        if (peerIndex >= peerConfigs.length) {
          logStatus('üõë Nelze se p≈ôipojit k ≈æ√°dn√©mu PeerJS serveru. Zkuste to znovu.');
          peerIndex = 0;
          return;
        }

        const configBase = peerConfigs[peerIndex];
        const peerConfig = { ...configBase, config: currentIceConfig };

        logStatus(`Zkou≈°√≠m PeerJS server (P≈ôij√≠maƒç): ${configBase.host}`);

        peerJs = new Peer(peerConfig);
        let opened = false;

        const errorTimeout = setTimeout(() => {
          if (!opened) {
            logStatus(`Timeout: Server ${configBase.host} neodpovƒõdƒõl. Zkou≈°√≠m dal≈°√≠...`);
            peerJs.destroy(); peerJs = null;
            peerIndex++;
            tryNextReceiver();
          }
        }, 8000); 

        peerJs.on('open', id => {
          opened = true;
          clearTimeout(errorTimeout);
          logStatus(`‚úÖ P≈ôij√≠maƒç Peer ID: ${id} p≈ôipojeno na server ${configBase.host}`);
          peerIndex = 0;
          updateReceiverControls(false);
        });

        peerJs.on('error', err => {
          clearTimeout(errorTimeout);
          logStatus(`‚ùå Chyba PeerJS p≈ôij√≠maƒçe na serveru ${configBase.host}: ${err.message}. Zkou≈°√≠m dal≈°√≠...`);
          peerJs.destroy(); peerJs = null;
          peerIndex++;
          tryNextReceiver();
        });

        peerJs.on('call', call => {
          if (mediaConn) mediaConn.close();
          call.answer(null);
          mediaConn = call;

          call.on('stream', remoteStream => {
            logStatus('P≈ôijat Audio stream!');
            audioReceiver.srcObject = remoteStream;
            unmuteBtn.style.display = 'none'; 

            audioReceiver.play().catch(e => {
              unmuteBtn.style.display = 'block'; 
              logStatus('P≈ôehr√°v√°n√≠ zablokov√°no. KLIKNƒöTE pro povolen√≠ zvuku!');
              updateReceiverControls(false);
            });
            updateReceiverControls(true);
          });

          call.on('close', () => {
            logStatus('Stream ukonƒçen vys√≠laƒçem.');
            audioReceiver.srcObject = null;
            mediaConn = null;
            unmuteBtn.style.display = 'none';
            updateReceiverControls(false);
          });

          call.on('error', err => { logStatus('Chyba streamu: ' + err); audioReceiver.srcObject = null; mediaConn = null; unmuteBtn.style.display = 'none'; updateReceiverControls(false); });
        });
      }

      peerIndex = 0;
      tryNextReceiver();

      connectBtn.onclick = () => {
        if (!peerJs || !peerJs.open) { logStatus('Nelze nav√°zat spojen√≠, PeerJS nen√≠ inicializov√°n/otev≈ôen.'); return; }
        if (conn) { conn.close(); conn = null; }
        const senderId = peerIdInput.value.trim();
        if (!senderId) { alert('Zadej Peer ID vys√≠laƒçe'); return; }
        
        conn = peerJs.connect(senderId, { reliable: true, serialization: 'json', metadata: {} });

        conn.on('open', () => { logStatus('P≈ôipojeno k vys√≠laƒçi (DataChannel).'); updateReceiverControls(true); });
        conn.on('data', handleDataMessage);
        conn.on('close', () => { logStatus('Spojen√≠ ukonƒçeno.'); conn = null; updateReceiverControls(false); if (mediaConn) mediaConn.close(); });
        conn.on('error', err => { logStatus('Chyba spojen√≠: ' + err); console.error(err); });
      };
    }
    // --- KONEC startReceiver ---

    // --- LOGIKA PRO OBSLUHU TLAƒå√çTKA SKENOV√ÅN√ç A VKL√ÅD√ÅN√ç (z≈Øst√°v√° stejn√°) ---
    scanQrBtn.onclick = () => {
        if (html5QrCode && html5QrCode.isScanning) {
            html5QrCode.stop().then(() => { readerContainer.innerHTML = '<div id="reader"></div>'; }).catch(err => console.error("Chyba p≈ôi zastavov√°n√≠ skeneru", err));
            return;
        }

        const config = { fps: 10, qrbox: { width: 250, height: 250 } };
        html5QrCode = new Html5Qrcode("reader");
        
        logStatus('Spou≈°t√≠m skener. Povolte p≈ô√≠stup ke kame≈ôe...');

        html5QrCode.start({ facingMode: "environment" }, config, 
            (decodedText) => {
                peerIdInput.value = decodedText;
                logStatus(`QR k√≥d naskenov√°n: ${decodedText}`);
                
                html5QrCode.stop().then(() => {
                    readerContainer.innerHTML = '<div id="reader"></div>';
                    html5QrCode = null;
                    connectBtn.click(); 
                }).catch(err => console.error("Chyba p≈ôi zastavov√°n√≠ skeneru", err));
            },
            (errorMessage) => {})
        .catch(err => { logStatus("üõë Chyba spu≈°tƒõn√≠ skeneru. Povolte p≈ô√≠stup ke kame≈ôe."); readerContainer.innerHTML = '<div id="reader"></div>'; html5QrCode = null; });
    };
    
    pasteIdBtn.onclick = () => {
        navigator.clipboard.readText().then(text => {
            if (text) {
                peerIdInput.value = text.trim();
                logStatus('‚úÖ Peer ID vlo≈æeno ze schr√°nky. Zkus√≠m p≈ôipojen√≠...');
                connectBtn.click();
            } else { logStatus('üõë Schr√°nka je pr√°zdn√° nebo neobsahuje text.'); }
        }).catch(err => { logStatus('üõë Nelze p≈ôistoupit ke schr√°nce. Povolte p≈ô√≠stup.'); console.error('Chyba ƒçten√≠ schr√°nky:', err); });
    };
    // --- KONEC LOGIKY SKENOV√ÅN√ç A VKL√ÅD√ÅN√ç ---

    // --- Reakce na zmƒõnu role ---
    roleSelect.addEventListener('change', () => {
      if (peerJs) { peerJs.destroy(); peerJs = null; }
      stopMediaStream(false); 
      playlist = [];
      currentTrackIndex = -1;
      updatePlaylistUI();
      showUI(roleSelect.value);
      peerIndex = 0;

      if (roleSelect.value === 'sender') {
        initPeerBtn.disabled = false;
        addToPlaylistBtn.disabled = true;
      } else {
        startReceiver();
      }
    });

    // --- Inicializace UI a role p≈ôi naƒçten√≠ ---
    showUI(roleSelect.value);

    if (roleSelect.value === 'sender') {
      initPeerBtn.disabled = false;
      addToPlaylistBtn.disabled = true;
    } else {
      startReceiver();
    }
    
    loadPlaylistFromLocal();


    initPeerBtn.onclick = () => {
      const peerId = senderPeerIdInput.value.trim();
      if (!peerId) { alert('Zadej vlastn√≠ Peer ID pro vys√≠laƒç'); return; }
      localStorage.setItem(SENDER_ID_KEY, peerId); 
      startSender(peerId);
    };
    
    // --- OBSLUHA TLAƒå√çTKA addUrlToPlaylistBtn (z≈Øst√°v√° stejn√°) ---
    addUrlToPlaylistBtn.addEventListener('click', async () => {
        const originalUrl = streamUrlInput.value.trim();
        if (!originalUrl) { logStatus('Zadejte URL streamu (nap≈ô. Icecast).'); return; }
        
        logStatus('Zkou≈°√≠m naƒç√≠st URL stream a proxy. M≈Ø≈æe trvat a≈æ 8s...');
        
        const isEncoded = originalUrl.includes('%');
        let cleanUrl = originalUrl;
        if (isEncoded) { try { cleanUrl = decodeURIComponent(originalUrl); } catch(e) {} }
        
        async function attemptLoadTest(url, isProxy = false) {
            return new Promise(resolve => {
                const testAudio = new Audio();
                testAudio.crossOrigin = "anonymous"; 
                testAudio.src = url;
                
                let timeout = setTimeout(() => {
                    testAudio.removeEventListener('canplaythrough', handleSuccess);
                    testAudio.removeEventListener('error', handleError);
                    resolve(false);
                }, 8000); 

                function handleSuccess() {
                    clearTimeout(timeout);
                    resolve(true);
                }

                function handleError(e) {
                    clearTimeout(timeout);
                    console.warn(`Pokus o naƒçten√≠ selhal: ${url}`, e);
                    resolve(false);
                }

                testAudio.addEventListener('canplaythrough', handleSuccess, { once: true });
                testAudio.addEventListener('error', handleError, { once: true });
                testAudio.load();
            });
        }
        
        let loadedUrl = null;
        
        if (await attemptLoadTest(cleanUrl)) { loadedUrl = cleanUrl; }
        
        if (!loadedUrl) {
            for (const proxyBase of PROXIES) {
                let proxyUrl = proxyBase + (proxyBase.includes('raw?url=') ? encodeURIComponent(cleanUrl) : cleanUrl);
                if (await attemptLoadTest(proxyUrl, true)) { loadedUrl = proxyUrl; break; }
            }
        }
        
        if (loadedUrl) {
            playlist.push({ name: `[STREAM] ${originalUrl}`, url: loadedUrl });
            updatePlaylistUI();
            savePlaylistToLocal();
            
            streamUrlInput.value = ''; 
            
            logStatus(`‚úÖ Extern√≠ URL (Icecast/Stream) p≈ôid√°na do playlistu.`);
            
            if (currentTrackIndex === -1) { playTrack(playlist.length - 1, 0); }
            
        } else {
            logStatus('üõë Naƒçten√≠ extern√≠ho streamu selhalo i p≈ôes ve≈ôejn√© proxy. URL streamu je nedostupn√°.');
        }
    });
  </script>
</body>
</html>
